# shell script

## 셸 스크립트

- 실행할 커맨드 라인을 입력해 높은 파일.

### sh vs. bash

- sh는 긴 역사를 가졌지만 기능이 다소 적음. 단 과거에는 sh 기반 셸 스크립트가 많이 작성되었기 때문에 호환성, 이식성 측면에서는 sh에 장점이 있음.
- CentOS 등 레드햇 계열 배포판에서는 sh는 bash의 별명. sh 명령어를 실행하면 sh모드로 동작하기는 함.
- 우분투 등 데비안 계열에서는 sh가 bash를 사용하고 있음.
    - 즉, sh의 실체가 배포판에 따라 다르고 동작도 다른 것.
- 반면 bash는 어떤 운영체제에서도 동일하게 동작함. 최근 리눅스에서는 bash가 거의 기본으로 설치됨.
- bash는 풍부한 기능이 강점.

## 셸 스크립트 작성

```bash
$ du -h ~ | tail -n 1 <- 홈 디렉터리의 파일 사용량을 출력
$ vim homesize.sh <- 셸 스크립트 작성
```

```bash
#!/bin/bash <- 셔뱅(shebang)
du -h ~ | tail -n 1
```

```bash
$ chmod +x homesize.sh <- 실행 권한 부여
$ ./homesize.sh <- 셸 스크립트 실행
```

- 스크립트 실행 시 파일 이름 앞에 ./를 반드시 붙여야 함(현재 디렉터리 의미)

## 셸 스크립트 실행 방법

### 셔뱅

- 셸 스크립트의 첫 행으로 **#!**로 시작
- 커널에게 이 스크립트가 어떤 셸로 실행되는지를 알려줌.
- #!/bin/bash 라고 입력하는 경우 리눅스 커널은 이 스크립트가 /bin/bash를 사용한다는 것으로 이해함.
- 즉, ./homesize.sh 실행을 셸에서 지시한 것이 /bin/bash ./homesize.sh 처럼 해석되어 실행됨.
- 배시를 표시한 셔뱅이 있으면 사용 중인 셸이 배시가 아니어도 /bin/bash가 스크립트를 실행함.
- 셸에서는 #로 시작하는 행을 주석으로 간주. 셔뱅도 주석으로 간주됨.
- 셔뱅의 경우 서브 셸로 실행되므로 환경 변수는 사용할 수 있지만 alias같은 별명 설정은 적용이 안됨.

## source 명령어

- 파일에서 명령어를 읽어서 실행하는 방법
- 셔뱅을 사용하지 않은 셸 스크립트의 경우 source 명령어로 실행 가능

```bash
du -h ~ | tail -n 1
```

```bash
$ source ./homesize-noshebang.sh
```

- source 명령어는 지정한 파일 안의 커맨드 라인을 셸에서 직접 입력한것과 동일하게 실행됨.
- 파일을 직접 실행하는 것이 아니므로 파일에 실행 권한을 부여할 필요가 없음.
- 또한 셔뱅으로 지정한 셸이 아니라 현재 사용 중인 셸이 사용됨.
- 배시에서는 . 명령어가 source와 동일하게 동작함.

```bash
$ . ./homesize-noshebang.sh
```

## 셸 스크립트 배치

- 일반적으로 상대 경로를 환경변수 PATH에 설정해 셸 스크립트를 실행
- 전용 디렉터리를 만든 후 이를 검색 경로에 추가하면 이름으로 셸 스크립트를 실행할 수 있음.

```bash
$ mkdir ~/bin
$ mv homesize.sh ~/bin
$ vim ~/.profile
```

- ~./profile 파일에 한 줄 추가해 검색 경로에 ~/bin을 추가

```bash
PATH="$PATH:~/bin"
```

- source 명령어로 설정을 적용

```bash
$ source ~/.profile
```

- 이후 이름만으로 셸 스크립트가 실행됨

```bash
$ homesize.sh
```

## 셸 스크립트 기초 지식

### 개행

- 커맨드 라인이 길어지는 경우 ‘\’를 넣어 개행할 수 있음.
- 셸에서도 ‘\’를 넣으면 커맨드 라인이 이어지며, 이처럼 커맨드 라인 입력이 끝나지 않은 프롬프트를 세컨더리 프롬프트라고 함.

### 주석

- ‘#’로 주석을 남김

### 변수

- 셸에서도 변수 지정 가능: 셸 변수
- 변수명=값의 형식으로 값을 대입.
- 변숫값을 참조하려면 변수명 앞에 $ 붙임. 반면 대입할 때는 $를 붙이지 않음.
- 또한 값 대입 시 변수 양옆에 공백이 없어야 함.

```bash
#!/bin/bash

appdir=/home/ldk/myapp
echo $appdir
```

- 변수와 문자열을 연결할 때는 변수를 {}로 감싼다

```bash
#!/bin/bash

filename=residue.dat
echo ${filename}_backup
```

- 쿼팅 시 작은 따옴표를 사용하면 $가 변수를 나타내는 것으로 인식되지 않음. 큰따옴표를 써야 변수로 인식.

```bash
#!/bin/bash

country=Korea
echo 'I came from $country'
echo "I came from $country"
```

```bash
$ ./quote.sh
```

### 명령어 치환

- 명령어를 실행하고 출력한 결과를 취득할 수 있는 기능
- $() 형식으로 괄호 안에 실행하려는 명령어 작성하거나 백쿼트(``)안에 명령어 작성

```bash
#!/bin/bash
filename=$(date '+%Y-%m-%d') <- filename 변수에 date를 변환한 결과값이 대입됨
touch "$filename"
```

- 단 백쿼트의 경우 명령어 치환에서 명령어 치환을 다시 사용하려면 \를 붙여야 함.

### 위치 파라미터

- 셸 변수의 하나로 명령어에서 인자의 위치를 나타내는 파라미터.
- $0, $1, $2 같은 형태이며 $0은 특수 파라미터에 해당함.
- 즉, 셸 스크립트에서 $2를 쓰면 명령어의 2번째 인자값을 그 자리에 할당함.
- 지정한 인자의 개수는 특수 파라미터인 $#로 참조

```bash
#!/bin/bash

echo "\$0 = $0"
echo "\$1 = $1"
echo "\$2 = $2"
echo "\$3 = $3"
echo "\$4 = $4"
echo "\$5 = $5"
echo "\$# = $#"
```

```bash
$ ./parameters.sh aaa bbb ccc
$0 = ./parameters.sh
$1 = aaa
$2 = bbb
$3 = ccc
$4 = 
$5 = 
$# = 3  <- 인자는 3개
```

- 인자를 분할하지 않고 전체를 참조하고 싶으면 $@ 또는 $*를 사용
    - 단, $@는 파라미터를 각각의 문자열로 참조하고 $*는 하나의 문자열로 참조
    - 대부분 인자를 하나씩 취득해서 처리하기 때문에 $@ 사용이 대부분. $*는 거의 사용되지 않음.